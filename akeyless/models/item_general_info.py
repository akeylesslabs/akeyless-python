# coding: utf-8

"""
    Akeyless API

    The purpose of this application is to provide access to Akeyless API.

    The version of the OpenAPI document: 3.0
    Contact: support@akeyless.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from akeyless.models.certificate_chain_info import CertificateChainInfo
from akeyless.models.certificate_expiration_event import CertificateExpirationEvent
from akeyless.models.certificate_issue_info import CertificateIssueInfo
from akeyless.models.certificate_template_info import CertificateTemplateInfo
from akeyless.models.classic_key_details_info import ClassicKeyDetailsInfo
from akeyless.models.dynamic_secret_producer_info import DynamicSecretProducerInfo
from akeyless.models.importer_info import ImporterInfo
from akeyless.models.next_auto_rotation_event import NextAutoRotationEvent
from akeyless.models.oidc_client_info import OidcClientInfo
from akeyless.models.password_policy_info import PasswordPolicyInfo
from akeyless.models.rotated_secret_details_info import RotatedSecretDetailsInfo
from akeyless.models.secure_remote_access import SecureRemoteAccess
from akeyless.models.static_secret_details_info import StaticSecretDetailsInfo
from akeyless.models.tokenizer_info import TokenizerInfo
from typing import Optional, Set
from typing_extensions import Self

class ItemGeneralInfo(BaseModel):
    """
    ItemGeneralInfo
    """ # noqa: E501
    cert_issue_details: Optional[CertificateIssueInfo] = None
    certificate_chain_info: Optional[CertificateChainInfo] = None
    certificate_format: Optional[StrictStr] = None
    certificates_template_info: Optional[CertificateTemplateInfo] = None
    classic_key_details: Optional[ClassicKeyDetailsInfo] = None
    cluster_gw_url: Optional[StrictStr] = None
    display_metadata: Optional[StrictStr] = None
    dynamic_secret_producer_details: Optional[DynamicSecretProducerInfo] = None
    expiration_events: Optional[List[CertificateExpirationEvent]] = None
    importer_info: Optional[ImporterInfo] = None
    next_rotation_events: Optional[List[NextAutoRotationEvent]] = None
    oidc_client_info: Optional[OidcClientInfo] = None
    password_policy: Optional[PasswordPolicyInfo] = None
    rotated_secret_details: Optional[RotatedSecretDetailsInfo] = None
    secure_remote_access_details: Optional[SecureRemoteAccess] = None
    static_secret_info: Optional[StaticSecretDetailsInfo] = None
    tokenizer_info: Optional[TokenizerInfo] = None
    __properties: ClassVar[List[str]] = ["cert_issue_details", "certificate_chain_info", "certificate_format", "certificates_template_info", "classic_key_details", "cluster_gw_url", "display_metadata", "dynamic_secret_producer_details", "expiration_events", "importer_info", "next_rotation_events", "oidc_client_info", "password_policy", "rotated_secret_details", "secure_remote_access_details", "static_secret_info", "tokenizer_info"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ItemGeneralInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of cert_issue_details
        if self.cert_issue_details:
            _dict['cert_issue_details'] = self.cert_issue_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of certificate_chain_info
        if self.certificate_chain_info:
            _dict['certificate_chain_info'] = self.certificate_chain_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of certificates_template_info
        if self.certificates_template_info:
            _dict['certificates_template_info'] = self.certificates_template_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of classic_key_details
        if self.classic_key_details:
            _dict['classic_key_details'] = self.classic_key_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dynamic_secret_producer_details
        if self.dynamic_secret_producer_details:
            _dict['dynamic_secret_producer_details'] = self.dynamic_secret_producer_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in expiration_events (list)
        _items = []
        if self.expiration_events:
            for _item_expiration_events in self.expiration_events:
                if _item_expiration_events:
                    _items.append(_item_expiration_events.to_dict())
            _dict['expiration_events'] = _items
        # override the default output from pydantic by calling `to_dict()` of importer_info
        if self.importer_info:
            _dict['importer_info'] = self.importer_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in next_rotation_events (list)
        _items = []
        if self.next_rotation_events:
            for _item_next_rotation_events in self.next_rotation_events:
                if _item_next_rotation_events:
                    _items.append(_item_next_rotation_events.to_dict())
            _dict['next_rotation_events'] = _items
        # override the default output from pydantic by calling `to_dict()` of oidc_client_info
        if self.oidc_client_info:
            _dict['oidc_client_info'] = self.oidc_client_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of password_policy
        if self.password_policy:
            _dict['password_policy'] = self.password_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of rotated_secret_details
        if self.rotated_secret_details:
            _dict['rotated_secret_details'] = self.rotated_secret_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of secure_remote_access_details
        if self.secure_remote_access_details:
            _dict['secure_remote_access_details'] = self.secure_remote_access_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of static_secret_info
        if self.static_secret_info:
            _dict['static_secret_info'] = self.static_secret_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of tokenizer_info
        if self.tokenizer_info:
            _dict['tokenizer_info'] = self.tokenizer_info.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ItemGeneralInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "cert_issue_details": CertificateIssueInfo.from_dict(obj["cert_issue_details"]) if obj.get("cert_issue_details") is not None else None,
            "certificate_chain_info": CertificateChainInfo.from_dict(obj["certificate_chain_info"]) if obj.get("certificate_chain_info") is not None else None,
            "certificate_format": obj.get("certificate_format"),
            "certificates_template_info": CertificateTemplateInfo.from_dict(obj["certificates_template_info"]) if obj.get("certificates_template_info") is not None else None,
            "classic_key_details": ClassicKeyDetailsInfo.from_dict(obj["classic_key_details"]) if obj.get("classic_key_details") is not None else None,
            "cluster_gw_url": obj.get("cluster_gw_url"),
            "display_metadata": obj.get("display_metadata"),
            "dynamic_secret_producer_details": DynamicSecretProducerInfo.from_dict(obj["dynamic_secret_producer_details"]) if obj.get("dynamic_secret_producer_details") is not None else None,
            "expiration_events": [CertificateExpirationEvent.from_dict(_item) for _item in obj["expiration_events"]] if obj.get("expiration_events") is not None else None,
            "importer_info": ImporterInfo.from_dict(obj["importer_info"]) if obj.get("importer_info") is not None else None,
            "next_rotation_events": [NextAutoRotationEvent.from_dict(_item) for _item in obj["next_rotation_events"]] if obj.get("next_rotation_events") is not None else None,
            "oidc_client_info": OidcClientInfo.from_dict(obj["oidc_client_info"]) if obj.get("oidc_client_info") is not None else None,
            "password_policy": PasswordPolicyInfo.from_dict(obj["password_policy"]) if obj.get("password_policy") is not None else None,
            "rotated_secret_details": RotatedSecretDetailsInfo.from_dict(obj["rotated_secret_details"]) if obj.get("rotated_secret_details") is not None else None,
            "secure_remote_access_details": SecureRemoteAccess.from_dict(obj["secure_remote_access_details"]) if obj.get("secure_remote_access_details") is not None else None,
            "static_secret_info": StaticSecretDetailsInfo.from_dict(obj["static_secret_info"]) if obj.get("static_secret_info") is not None else None,
            "tokenizer_info": TokenizerInfo.from_dict(obj["tokenizer_info"]) if obj.get("tokenizer_info") is not None else None
        })
        return _obj


