# coding: utf-8

"""
    Akeyless API

    The purpose of this application is to provide access to Akeyless API.

    The version of the OpenAPI document: 2.0
    Contact: support@akeyless.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class CreatePKICertIssuer(BaseModel):
    """
    CreatePKICertIssuer
    """ # noqa: E501
    allow_any_name: Optional[StrictBool] = Field(default=None, description="If set, clients can request certificates for any CN", alias="allow-any-name")
    allow_copy_ext_from_csr: Optional[StrictBool] = Field(default=None, description="If set, will allow copying the extra extensions from the csr file (if given)", alias="allow-copy-ext-from-csr")
    allow_subdomains: Optional[StrictBool] = Field(default=None, description="If set, clients can request certificates for subdomains and wildcard subdomains of the allowed domains", alias="allow-subdomains")
    allowed_domains: Optional[StrictStr] = Field(default=None, description="A list of the allowed domains that clients can request to be included in the certificate (in a comma-delimited list)", alias="allowed-domains")
    allowed_extra_extensions: Optional[StrictStr] = Field(default=None, description="A json string containing the allowed extra extensions for the pki cert issuer", alias="allowed-extra-extensions")
    allowed_ip_sans: Optional[StrictStr] = Field(default=None, description="A list of the allowed CIDRs for ips that clients can request to be included in the certificate as part of the IP Subject Alternative Names (in a comma-delimited list)", alias="allowed-ip-sans")
    allowed_uri_sans: Optional[StrictStr] = Field(default=None, description="A list of the allowed URIs that clients can request to be included in the certificate as part of the URI Subject Alternative Names (in a comma-delimited list)", alias="allowed-uri-sans")
    auto_renew: Optional[StrictBool] = Field(default=None, description="Automatically renew certificates before expiration", alias="auto-renew")
    ca_target: Optional[StrictStr] = Field(default=None, description="The name of an existing CA target to attach this PKI Certificate Issuer to, required in Public CA mode", alias="ca-target")
    client_flag: Optional[StrictBool] = Field(default=None, description="If set, certificates will be flagged for client auth use", alias="client-flag")
    code_signing_flag: Optional[StrictBool] = Field(default=None, description="If set, certificates will be flagged for code signing use", alias="code-signing-flag")
    country: Optional[StrictStr] = Field(default=None, description="A comma-separated list of countries that will be set in the issued certificate")
    create_private_crl: Optional[StrictBool] = Field(default=None, description="Set this to allow the issuer will expose a CRL endpoint in the Gateway", alias="create-private-crl")
    create_public_crl: Optional[StrictBool] = Field(default=None, description="Set this to allow the cert issuer will expose a public CRL endpoint", alias="create-public-crl")
    critical_key_usage: Optional[StrictStr] = Field(default='true', description="Mark key usage as critical [true/false]", alias="critical-key-usage")
    delete_protection: Optional[StrictStr] = Field(default=None, description="Protection from accidental deletion of this object [true/false]")
    description: Optional[StrictStr] = Field(default=None, description="Description of the object")
    destination_path: Optional[StrictStr] = Field(default=None, description="A path in which to save generated certificates", alias="destination-path")
    enable_acme: Optional[StrictBool] = Field(default=None, description="If set, the cert issuer will support the acme protocol", alias="enable-acme")
    expiration_event_in: Optional[List[StrictStr]] = Field(default=None, description="How many days before the expiration of the certificate would you like to be notified.", alias="expiration-event-in")
    gw_cluster_url: Optional[StrictStr] = Field(default=None, description="The GW cluster URL to issue the certificate from. Required in Public CA mode, to allow CRLs on private CA, or to enable ACME", alias="gw-cluster-url")
    is_ca: Optional[StrictBool] = Field(default=None, description="If set, the basic constraints extension will be added to certificate", alias="is-ca")
    var_json: Optional[StrictBool] = Field(default=False, description="Set output format to JSON", alias="json")
    key_usage: Optional[StrictStr] = Field(default='DigitalSignature,KeyAgreement,KeyEncipherment', description="key-usage", alias="key-usage")
    locality: Optional[StrictStr] = Field(default=None, description="A comma-separated list of localities that will be set in the issued certificate")
    max_path_len: Optional[StrictInt] = Field(default=-1, description="The maximum path length for the generated certificate. -1, means unlimited", alias="max-path-len")
    metadata: Optional[StrictStr] = Field(default=None, description="Deprecated - use description")
    name: StrictStr = Field(description="PKI certificate issuer name")
    not_enforce_hostnames: Optional[StrictBool] = Field(default=None, description="If set, any names are allowed for CN and SANs in the certificate and not only a valid host name", alias="not-enforce-hostnames")
    not_require_cn: Optional[StrictBool] = Field(default=None, description="If set, clients can request certificates without a CN", alias="not-require-cn")
    organizational_units: Optional[StrictStr] = Field(default=None, description="A comma-separated list of organizational units (OU) that will be set in the issued certificate", alias="organizational-units")
    organizations: Optional[StrictStr] = Field(default=None, description="A comma-separated list of organizations (O) that will be set in the issued certificate")
    postal_code: Optional[StrictStr] = Field(default=None, description="A comma-separated list of postal codes that will be set in the issued certificate", alias="postal-code")
    protect_certificates: Optional[StrictBool] = Field(default=None, description="Whether to protect generated certificates from deletion", alias="protect-certificates")
    province: Optional[StrictStr] = Field(default=None, description="A comma-separated list of provinces that will be set in the issued certificate")
    scheduled_renew: Optional[StrictInt] = Field(default=None, description="Number of days before expiration to renew certificates", alias="scheduled-renew")
    server_flag: Optional[StrictBool] = Field(default=None, description="If set, certificates will be flagged for server auth use", alias="server-flag")
    signer_key_name: Optional[StrictStr] = Field(default=None, description="A key to sign the certificate with, required in Private CA mode", alias="signer-key-name")
    street_address: Optional[StrictStr] = Field(default=None, description="A comma-separated list of street addresses that will be set in the issued certificate", alias="street-address")
    tag: Optional[List[StrictStr]] = Field(default=None, description="List of the tags attached to this key")
    token: Optional[StrictStr] = Field(default=None, description="Authentication token (see `/auth` and `/configure`)")
    ttl: StrictStr = Field(description="The maximum requested Time To Live for issued certificates, in seconds. In case of Public CA, this is based on the CA target's supported maximum TTLs")
    uid_token: Optional[StrictStr] = Field(default=None, description="The universal identity token, Required only for universal_identity authentication", alias="uid-token")
    __properties: ClassVar[List[str]] = ["allow-any-name", "allow-copy-ext-from-csr", "allow-subdomains", "allowed-domains", "allowed-extra-extensions", "allowed-ip-sans", "allowed-uri-sans", "auto-renew", "ca-target", "client-flag", "code-signing-flag", "country", "create-private-crl", "create-public-crl", "critical-key-usage", "delete_protection", "description", "destination-path", "enable-acme", "expiration-event-in", "gw-cluster-url", "is-ca", "json", "key-usage", "locality", "max-path-len", "metadata", "name", "not-enforce-hostnames", "not-require-cn", "organizational-units", "organizations", "postal-code", "protect-certificates", "province", "scheduled-renew", "server-flag", "signer-key-name", "street-address", "tag", "token", "ttl", "uid-token"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreatePKICertIssuer from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreatePKICertIssuer from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "allow-any-name": obj.get("allow-any-name"),
            "allow-copy-ext-from-csr": obj.get("allow-copy-ext-from-csr"),
            "allow-subdomains": obj.get("allow-subdomains"),
            "allowed-domains": obj.get("allowed-domains"),
            "allowed-extra-extensions": obj.get("allowed-extra-extensions"),
            "allowed-ip-sans": obj.get("allowed-ip-sans"),
            "allowed-uri-sans": obj.get("allowed-uri-sans"),
            "auto-renew": obj.get("auto-renew"),
            "ca-target": obj.get("ca-target"),
            "client-flag": obj.get("client-flag"),
            "code-signing-flag": obj.get("code-signing-flag"),
            "country": obj.get("country"),
            "create-private-crl": obj.get("create-private-crl"),
            "create-public-crl": obj.get("create-public-crl"),
            "critical-key-usage": obj.get("critical-key-usage") if obj.get("critical-key-usage") is not None else 'true',
            "delete_protection": obj.get("delete_protection"),
            "description": obj.get("description"),
            "destination-path": obj.get("destination-path"),
            "enable-acme": obj.get("enable-acme"),
            "expiration-event-in": obj.get("expiration-event-in"),
            "gw-cluster-url": obj.get("gw-cluster-url"),
            "is-ca": obj.get("is-ca"),
            "json": obj.get("json") if obj.get("json") is not None else False,
            "key-usage": obj.get("key-usage") if obj.get("key-usage") is not None else 'DigitalSignature,KeyAgreement,KeyEncipherment',
            "locality": obj.get("locality"),
            "max-path-len": obj.get("max-path-len") if obj.get("max-path-len") is not None else -1,
            "metadata": obj.get("metadata"),
            "name": obj.get("name"),
            "not-enforce-hostnames": obj.get("not-enforce-hostnames"),
            "not-require-cn": obj.get("not-require-cn"),
            "organizational-units": obj.get("organizational-units"),
            "organizations": obj.get("organizations"),
            "postal-code": obj.get("postal-code"),
            "protect-certificates": obj.get("protect-certificates"),
            "province": obj.get("province"),
            "scheduled-renew": obj.get("scheduled-renew"),
            "server-flag": obj.get("server-flag"),
            "signer-key-name": obj.get("signer-key-name"),
            "street-address": obj.get("street-address"),
            "tag": obj.get("tag"),
            "token": obj.get("token"),
            "ttl": obj.get("ttl"),
            "uid-token": obj.get("uid-token")
        })
        return _obj


