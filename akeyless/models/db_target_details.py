# coding: utf-8

"""
    Akeyless API

    The purpose of this application is to provide access to Akeyless API.

    The version of the OpenAPI document: 2.0
    Contact: support@akeyless.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from akeyless.models.wallet_details import WalletDetails
from typing import Optional, Set
from typing_extensions import Self

class DbTargetDetails(BaseModel):
    """
    DbTargetDetails
    """ # noqa: E501
    cloud_service_provider: Optional[StrictStr] = None
    cluster_mode: Optional[StrictBool] = None
    connection_type: Optional[StrictStr] = None
    db_client_id: Optional[StrictStr] = None
    db_client_secret: Optional[StrictStr] = None
    db_host_name: Optional[StrictStr] = None
    db_name: Optional[StrictStr] = None
    db_port: Optional[StrictStr] = None
    db_private_key: Optional[StrictStr] = Field(default=None, description="(Optional) Private Key in PEM format")
    db_private_key_passphrase: Optional[StrictStr] = None
    db_pwd: Optional[StrictStr] = None
    db_server_certificates: Optional[StrictStr] = Field(default=None, description="(Optional) DBServerCertificates defines the set of root certificate authorities that clients use when verifying server certificates. If DBServerCertificates is empty, TLS uses the host's root CA set.")
    db_server_name: Optional[StrictStr] = Field(default=None, description="(Optional) ServerName is used to verify the hostname on the returned certificates unless InsecureSkipVerify is given. It is also included in the client's handshake to support virtual hosting unless it is an IP address.")
    db_tenant_id: Optional[StrictStr] = None
    db_user_name: Optional[StrictStr] = None
    oracle_wallet_details: Optional[WalletDetails] = None
    sf_account: Optional[StrictStr] = None
    ssl_connection_certificate: Optional[StrictStr] = Field(default=None, description="(Optional) SSLConnectionCertificate defines the certificate for SSL connection. Must be base64 certificate loaded by UI using file loader field")
    ssl_connection_mode: Optional[StrictBool] = Field(default=None, description="(Optional) SSLConnectionMode defines if SSL mode will be used to connect to DB")
    __properties: ClassVar[List[str]] = ["cloud_service_provider", "cluster_mode", "connection_type", "db_client_id", "db_client_secret", "db_host_name", "db_name", "db_port", "db_private_key", "db_private_key_passphrase", "db_pwd", "db_server_certificates", "db_server_name", "db_tenant_id", "db_user_name", "oracle_wallet_details", "sf_account", "ssl_connection_certificate", "ssl_connection_mode"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DbTargetDetails from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of oracle_wallet_details
        if self.oracle_wallet_details:
            _dict['oracle_wallet_details'] = self.oracle_wallet_details.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DbTargetDetails from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "cloud_service_provider": obj.get("cloud_service_provider"),
            "cluster_mode": obj.get("cluster_mode"),
            "connection_type": obj.get("connection_type"),
            "db_client_id": obj.get("db_client_id"),
            "db_client_secret": obj.get("db_client_secret"),
            "db_host_name": obj.get("db_host_name"),
            "db_name": obj.get("db_name"),
            "db_port": obj.get("db_port"),
            "db_private_key": obj.get("db_private_key"),
            "db_private_key_passphrase": obj.get("db_private_key_passphrase"),
            "db_pwd": obj.get("db_pwd"),
            "db_server_certificates": obj.get("db_server_certificates"),
            "db_server_name": obj.get("db_server_name"),
            "db_tenant_id": obj.get("db_tenant_id"),
            "db_user_name": obj.get("db_user_name"),
            "oracle_wallet_details": WalletDetails.from_dict(obj["oracle_wallet_details"]) if obj.get("oracle_wallet_details") is not None else None,
            "sf_account": obj.get("sf_account"),
            "ssl_connection_certificate": obj.get("ssl_connection_certificate"),
            "ssl_connection_mode": obj.get("ssl_connection_mode")
        })
        return _obj


