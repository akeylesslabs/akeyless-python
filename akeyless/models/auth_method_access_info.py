# coding: utf-8

"""
    Akeyless API

    The purpose of this application is to provide access to Akeyless API.

    The version of the OpenAPI document: 3.0
    Contact: support@akeyless.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from akeyless.models.api_key_access_rules import APIKeyAccessRules
from akeyless.models.awsiam_access_rules import AWSIAMAccessRules
from akeyless.models.azure_ad_access_rules import AzureADAccessRules
from akeyless.models.cert_access_rules import CertAccessRules
from akeyless.models.email_pass_access_rules import EmailPassAccessRules
from akeyless.models.gcp_access_rules import GCPAccessRules
from akeyless.models.huawei_access_rules import HuaweiAccessRules
from akeyless.models.kerberos_access_rules import KerberosAccessRules
from akeyless.models.kubernetes_access_rules import KubernetesAccessRules
from akeyless.models.ldap_access_rules import LDAPAccessRules
from akeyless.models.o_auth2_access_rules import OAuth2AccessRules
from akeyless.models.oci_access_rules import OCIAccessRules
from akeyless.models.oidc_access_rules import OIDCAccessRules
from akeyless.models.saml_access_rules import SAMLAccessRules
from akeyless.models.universal_identity_access_rules import UniversalIdentityAccessRules
from typing import Optional, Set
from typing_extensions import Self

class AuthMethodAccessInfo(BaseModel):
    """
    AuthMethodAccessInfo
    """ # noqa: E501
    access_expires: Optional[StrictInt] = None
    access_id_alias: Optional[StrictStr] = Field(default=None, description="for accounts where AccessId holds encrypted email this field will hold generated AccessId, for accounts based on regular AccessId it will be equal to accessId itself")
    api_key_access_rules: Optional[APIKeyAccessRules] = None
    audit_logs_claims: Optional[List[StrictStr]] = None
    aws_iam_access_rules: Optional[AWSIAMAccessRules] = None
    azure_ad_access_rules: Optional[AzureADAccessRules] = None
    cert_access_rules: Optional[CertAccessRules] = None
    cidr_whitelist: Optional[StrictStr] = None
    email_pass_access_rules: Optional[EmailPassAccessRules] = None
    force_sub_claims: Optional[StrictBool] = Field(default=None, description="if true the role associated with this auth method must include sub claims")
    gcp_access_rules: Optional[GCPAccessRules] = None
    gw_cidr_whitelist: Optional[StrictStr] = None
    huawei_access_rules: Optional[HuaweiAccessRules] = None
    jwt_ttl: Optional[StrictInt] = None
    k8s_access_rules: Optional[KubernetesAccessRules] = None
    kerberos_access_rules: Optional[KerberosAccessRules] = None
    ldap_access_rules: Optional[LDAPAccessRules] = None
    oauth2_access_rules: Optional[OAuth2AccessRules] = None
    oci_access_rules: Optional[OCIAccessRules] = None
    oidc_access_rules: Optional[OIDCAccessRules] = None
    product_types: Optional[List[StrictStr]] = Field(default=None, description="List of product types this auth method will be in use of")
    rules_type: Optional[StrictStr] = None
    saml_access_rules: Optional[SAMLAccessRules] = None
    sub_claims_delimiters: Optional[List[StrictStr]] = None
    universal_identity_access_rules: Optional[UniversalIdentityAccessRules] = None
    __properties: ClassVar[List[str]] = ["access_expires", "access_id_alias", "api_key_access_rules", "audit_logs_claims", "aws_iam_access_rules", "azure_ad_access_rules", "cert_access_rules", "cidr_whitelist", "email_pass_access_rules", "force_sub_claims", "gcp_access_rules", "gw_cidr_whitelist", "huawei_access_rules", "jwt_ttl", "k8s_access_rules", "kerberos_access_rules", "ldap_access_rules", "oauth2_access_rules", "oci_access_rules", "oidc_access_rules", "product_types", "rules_type", "saml_access_rules", "sub_claims_delimiters", "universal_identity_access_rules"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AuthMethodAccessInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of api_key_access_rules
        if self.api_key_access_rules:
            _dict['api_key_access_rules'] = self.api_key_access_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of aws_iam_access_rules
        if self.aws_iam_access_rules:
            _dict['aws_iam_access_rules'] = self.aws_iam_access_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of azure_ad_access_rules
        if self.azure_ad_access_rules:
            _dict['azure_ad_access_rules'] = self.azure_ad_access_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cert_access_rules
        if self.cert_access_rules:
            _dict['cert_access_rules'] = self.cert_access_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of email_pass_access_rules
        if self.email_pass_access_rules:
            _dict['email_pass_access_rules'] = self.email_pass_access_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of gcp_access_rules
        if self.gcp_access_rules:
            _dict['gcp_access_rules'] = self.gcp_access_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of huawei_access_rules
        if self.huawei_access_rules:
            _dict['huawei_access_rules'] = self.huawei_access_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of k8s_access_rules
        if self.k8s_access_rules:
            _dict['k8s_access_rules'] = self.k8s_access_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of kerberos_access_rules
        if self.kerberos_access_rules:
            _dict['kerberos_access_rules'] = self.kerberos_access_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ldap_access_rules
        if self.ldap_access_rules:
            _dict['ldap_access_rules'] = self.ldap_access_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of oauth2_access_rules
        if self.oauth2_access_rules:
            _dict['oauth2_access_rules'] = self.oauth2_access_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of oci_access_rules
        if self.oci_access_rules:
            _dict['oci_access_rules'] = self.oci_access_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of oidc_access_rules
        if self.oidc_access_rules:
            _dict['oidc_access_rules'] = self.oidc_access_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of saml_access_rules
        if self.saml_access_rules:
            _dict['saml_access_rules'] = self.saml_access_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of universal_identity_access_rules
        if self.universal_identity_access_rules:
            _dict['universal_identity_access_rules'] = self.universal_identity_access_rules.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AuthMethodAccessInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "access_expires": obj.get("access_expires"),
            "access_id_alias": obj.get("access_id_alias"),
            "api_key_access_rules": APIKeyAccessRules.from_dict(obj["api_key_access_rules"]) if obj.get("api_key_access_rules") is not None else None,
            "audit_logs_claims": obj.get("audit_logs_claims"),
            "aws_iam_access_rules": AWSIAMAccessRules.from_dict(obj["aws_iam_access_rules"]) if obj.get("aws_iam_access_rules") is not None else None,
            "azure_ad_access_rules": AzureADAccessRules.from_dict(obj["azure_ad_access_rules"]) if obj.get("azure_ad_access_rules") is not None else None,
            "cert_access_rules": CertAccessRules.from_dict(obj["cert_access_rules"]) if obj.get("cert_access_rules") is not None else None,
            "cidr_whitelist": obj.get("cidr_whitelist"),
            "email_pass_access_rules": EmailPassAccessRules.from_dict(obj["email_pass_access_rules"]) if obj.get("email_pass_access_rules") is not None else None,
            "force_sub_claims": obj.get("force_sub_claims"),
            "gcp_access_rules": GCPAccessRules.from_dict(obj["gcp_access_rules"]) if obj.get("gcp_access_rules") is not None else None,
            "gw_cidr_whitelist": obj.get("gw_cidr_whitelist"),
            "huawei_access_rules": HuaweiAccessRules.from_dict(obj["huawei_access_rules"]) if obj.get("huawei_access_rules") is not None else None,
            "jwt_ttl": obj.get("jwt_ttl"),
            "k8s_access_rules": KubernetesAccessRules.from_dict(obj["k8s_access_rules"]) if obj.get("k8s_access_rules") is not None else None,
            "kerberos_access_rules": KerberosAccessRules.from_dict(obj["kerberos_access_rules"]) if obj.get("kerberos_access_rules") is not None else None,
            "ldap_access_rules": LDAPAccessRules.from_dict(obj["ldap_access_rules"]) if obj.get("ldap_access_rules") is not None else None,
            "oauth2_access_rules": OAuth2AccessRules.from_dict(obj["oauth2_access_rules"]) if obj.get("oauth2_access_rules") is not None else None,
            "oci_access_rules": OCIAccessRules.from_dict(obj["oci_access_rules"]) if obj.get("oci_access_rules") is not None else None,
            "oidc_access_rules": OIDCAccessRules.from_dict(obj["oidc_access_rules"]) if obj.get("oidc_access_rules") is not None else None,
            "product_types": obj.get("product_types"),
            "rules_type": obj.get("rules_type"),
            "saml_access_rules": SAMLAccessRules.from_dict(obj["saml_access_rules"]) if obj.get("saml_access_rules") is not None else None,
            "sub_claims_delimiters": obj.get("sub_claims_delimiters"),
            "universal_identity_access_rules": UniversalIdentityAccessRules.from_dict(obj["universal_identity_access_rules"]) if obj.get("universal_identity_access_rules") is not None else None
        })
        return _obj


