# coding: utf-8

"""
    Akeyless API

    The purpose of this application is to provide access to Akeyless API.

    The version of the OpenAPI document: 3.0
    Contact: support@akeyless.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from akeyless.models.bastions_list import BastionsList
from akeyless.models.certificate_issue_info import CertificateIssueInfo
from akeyless.models.gateway_basic_info import GatewayBasicInfo
from akeyless.models.item_general_info import ItemGeneralInfo
from akeyless.models.item_target_association import ItemTargetAssociation
from akeyless.models.item_usc_sync_association import ItemUSCSyncAssociation
from akeyless.models.item_version import ItemVersion
from akeyless.models.linked_details import LinkedDetails
from akeyless.models.rule_assigner import RuleAssigner
from akeyless.models.target_item_version import TargetItemVersion
from typing import Optional, Set
from typing_extensions import Self

class Item(BaseModel):
    """
    Item
    """ # noqa: E501
    access_date: Optional[datetime] = None
    access_date_display: Optional[StrictStr] = None
    access_request_status: Optional[StrictStr] = None
    auto_rotate: Optional[StrictBool] = None
    bastion_details: Optional[BastionsList] = None
    cert_issuer_signer_key_name: Optional[StrictStr] = None
    certificate_issue_details: Optional[CertificateIssueInfo] = None
    certificates: Optional[StrictStr] = None
    client_permissions: Optional[List[StrictStr]] = None
    creation_date: Optional[datetime] = None
    customer_fragment_id: Optional[StrictStr] = None
    delete_protection: Optional[StrictBool] = None
    deletion_date: Optional[datetime] = None
    display_id: Optional[StrictStr] = None
    gateway_details: Optional[List[GatewayBasicInfo]] = None
    is_access_request_enabled: Optional[StrictBool] = None
    is_enabled: Optional[StrictBool] = None
    item_accessibility: Optional[StrictInt] = None
    item_general_info: Optional[ItemGeneralInfo] = None
    item_id: Optional[StrictInt] = None
    item_metadata: Optional[StrictStr] = None
    item_name: Optional[StrictStr] = None
    item_size: Optional[StrictInt] = None
    item_state: Optional[StrictStr] = Field(default=None, description="ItemState defines the different states an Item can be in")
    item_sub_type: Optional[StrictStr] = None
    item_tags: Optional[List[StrictStr]] = None
    item_targets_assoc: Optional[List[ItemTargetAssociation]] = None
    item_type: Optional[StrictStr] = None
    item_versions: Optional[List[ItemVersion]] = None
    last_rotation_date: Optional[datetime] = None
    last_version: Optional[StrictInt] = None
    linked_details: Optional[LinkedDetails] = None
    modification_date: Optional[datetime] = None
    next_rotation_date: Optional[datetime] = None
    protection_key_name: Optional[StrictStr] = None
    protection_key_type: Optional[StrictStr] = None
    public_value: Optional[StrictStr] = None
    rotation_interval: Optional[StrictInt] = None
    shared_by: Optional[RuleAssigner] = None
    target_versions: Optional[List[TargetItemVersion]] = None
    usc_sync_associated_items: Optional[List[ItemUSCSyncAssociation]] = Field(default=None, description="for USC item, hold rotated-secrets that are associated to him for rotated-secret, holds the associated USCs")
    with_customer_fragment: Optional[StrictBool] = None
    __properties: ClassVar[List[str]] = ["access_date", "access_date_display", "access_request_status", "auto_rotate", "bastion_details", "cert_issuer_signer_key_name", "certificate_issue_details", "certificates", "client_permissions", "creation_date", "customer_fragment_id", "delete_protection", "deletion_date", "display_id", "gateway_details", "is_access_request_enabled", "is_enabled", "item_accessibility", "item_general_info", "item_id", "item_metadata", "item_name", "item_size", "item_state", "item_sub_type", "item_tags", "item_targets_assoc", "item_type", "item_versions", "last_rotation_date", "last_version", "linked_details", "modification_date", "next_rotation_date", "protection_key_name", "protection_key_type", "public_value", "rotation_interval", "shared_by", "target_versions", "usc_sync_associated_items", "with_customer_fragment"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Item from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of bastion_details
        if self.bastion_details:
            _dict['bastion_details'] = self.bastion_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of certificate_issue_details
        if self.certificate_issue_details:
            _dict['certificate_issue_details'] = self.certificate_issue_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in gateway_details (list)
        _items = []
        if self.gateway_details:
            for _item_gateway_details in self.gateway_details:
                if _item_gateway_details:
                    _items.append(_item_gateway_details.to_dict())
            _dict['gateway_details'] = _items
        # override the default output from pydantic by calling `to_dict()` of item_general_info
        if self.item_general_info:
            _dict['item_general_info'] = self.item_general_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in item_targets_assoc (list)
        _items = []
        if self.item_targets_assoc:
            for _item_item_targets_assoc in self.item_targets_assoc:
                if _item_item_targets_assoc:
                    _items.append(_item_item_targets_assoc.to_dict())
            _dict['item_targets_assoc'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in item_versions (list)
        _items = []
        if self.item_versions:
            for _item_item_versions in self.item_versions:
                if _item_item_versions:
                    _items.append(_item_item_versions.to_dict())
            _dict['item_versions'] = _items
        # override the default output from pydantic by calling `to_dict()` of linked_details
        if self.linked_details:
            _dict['linked_details'] = self.linked_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shared_by
        if self.shared_by:
            _dict['shared_by'] = self.shared_by.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in target_versions (list)
        _items = []
        if self.target_versions:
            for _item_target_versions in self.target_versions:
                if _item_target_versions:
                    _items.append(_item_target_versions.to_dict())
            _dict['target_versions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in usc_sync_associated_items (list)
        _items = []
        if self.usc_sync_associated_items:
            for _item_usc_sync_associated_items in self.usc_sync_associated_items:
                if _item_usc_sync_associated_items:
                    _items.append(_item_usc_sync_associated_items.to_dict())
            _dict['usc_sync_associated_items'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Item from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "access_date": obj.get("access_date"),
            "access_date_display": obj.get("access_date_display"),
            "access_request_status": obj.get("access_request_status"),
            "auto_rotate": obj.get("auto_rotate"),
            "bastion_details": BastionsList.from_dict(obj["bastion_details"]) if obj.get("bastion_details") is not None else None,
            "cert_issuer_signer_key_name": obj.get("cert_issuer_signer_key_name"),
            "certificate_issue_details": CertificateIssueInfo.from_dict(obj["certificate_issue_details"]) if obj.get("certificate_issue_details") is not None else None,
            "certificates": obj.get("certificates"),
            "client_permissions": obj.get("client_permissions"),
            "creation_date": obj.get("creation_date"),
            "customer_fragment_id": obj.get("customer_fragment_id"),
            "delete_protection": obj.get("delete_protection"),
            "deletion_date": obj.get("deletion_date"),
            "display_id": obj.get("display_id"),
            "gateway_details": [GatewayBasicInfo.from_dict(_item) for _item in obj["gateway_details"]] if obj.get("gateway_details") is not None else None,
            "is_access_request_enabled": obj.get("is_access_request_enabled"),
            "is_enabled": obj.get("is_enabled"),
            "item_accessibility": obj.get("item_accessibility"),
            "item_general_info": ItemGeneralInfo.from_dict(obj["item_general_info"]) if obj.get("item_general_info") is not None else None,
            "item_id": obj.get("item_id"),
            "item_metadata": obj.get("item_metadata"),
            "item_name": obj.get("item_name"),
            "item_size": obj.get("item_size"),
            "item_state": obj.get("item_state"),
            "item_sub_type": obj.get("item_sub_type"),
            "item_tags": obj.get("item_tags"),
            "item_targets_assoc": [ItemTargetAssociation.from_dict(_item) for _item in obj["item_targets_assoc"]] if obj.get("item_targets_assoc") is not None else None,
            "item_type": obj.get("item_type"),
            "item_versions": [ItemVersion.from_dict(_item) for _item in obj["item_versions"]] if obj.get("item_versions") is not None else None,
            "last_rotation_date": obj.get("last_rotation_date"),
            "last_version": obj.get("last_version"),
            "linked_details": LinkedDetails.from_dict(obj["linked_details"]) if obj.get("linked_details") is not None else None,
            "modification_date": obj.get("modification_date"),
            "next_rotation_date": obj.get("next_rotation_date"),
            "protection_key_name": obj.get("protection_key_name"),
            "protection_key_type": obj.get("protection_key_type"),
            "public_value": obj.get("public_value"),
            "rotation_interval": obj.get("rotation_interval"),
            "shared_by": RuleAssigner.from_dict(obj["shared_by"]) if obj.get("shared_by") is not None else None,
            "target_versions": [TargetItemVersion.from_dict(_item) for _item in obj["target_versions"]] if obj.get("target_versions") is not None else None,
            "usc_sync_associated_items": [ItemUSCSyncAssociation.from_dict(_item) for _item in obj["usc_sync_associated_items"]] if obj.get("usc_sync_associated_items") is not None else None,
            "with_customer_fragment": obj.get("with_customer_fragment")
        })
        return _obj


